
<div class="vertical-tabs-container">
  <div class="vertical-tabs">
    <a href="javascript:void(0)" class="js-vertical-tab vertical-tab is-active" rel="tab1">Sam Metevia</a>
    <a href="javascript:void(0)" class="js-vertical-tab vertical-tab" rel="tab2">Jacob Hersha</a>
    <a href="javascript:void(0)" class="js-vertical-tab vertical-tab" rel="tab3">Joshua Folks</a>
    <a href="javascript:void(0)" class="js-vertical-tab vertical-tab" rel="tab4">Joshua Johnson</a>
    <a href="javascript:void(0)" class="js-vertical-tab vertical-tab" rel="tab3">Michael Wright</a>
  </div>

  <div class="vertical-tab-content-container">
    <a href="" class="js-vertical-tab-accordion-heading vertical-tab-accordion-heading is-active" rel="tab1">Sam Metevia</a>
    <div id="tab1" class="js-vertical-tab-content vertical-tab-content">
      <h3>"The aim with the piano task was simple perfection; nothing less...</h3> <h3> Semicolons are fancy."</h3>
      </br>
      </br>
      <p>The piano plays notes that are sampled from a real life piano. It knows how to play the notes based on a score file that is written in the following format.</p> 

      </br>
      <h5>Piano Score format:</h5>
      <p>
      < note measure="1" beat="1" duration="8" note="PedalD" dynamic ="1.0"/></br>
      </br>
      "All notes come after <instrument instrument="Piano"> and then indented.
      </p>

      <p>Notes are in format e.g. B6# would be B#, 6th octave. The notes need to be in the correct order so that the program can select the proper file and waveform to play. 
      </p>

      <p>
      Duration is in beats. Measures and beats work as in Step 5. 
      If the note is a Pedal, like the pedal is pressed up or down. The state of the pedal effects how the other notes decay over time. With the pedal up, the notes decay fairly quickly. With the pedal down, their sound is held until a quick release happens at the end of their duration. 
      The dynamic is on a scale of 0 to 1.0 exclusively. 0 is a purely "soft" note, while 1.0 is a purely "loud" one. Intermediate values play a mixture of the two. For example, a value of 0.4 would be 40% loud and 60% soft. This is an attempt to provide advanced dynamics, as the load and soft notes have slightly different sounds, as in a real piano. 
      </p>

      <p>
      At the start of a program, the piano reads the notes that it needs to play. During playtime, if a piano instrument is to play at a given beat, the program uses a Piano Factory object to play the note. A Piano Factory makes a new Piano object and sets the note. The note is set based on the score format listed above. When it is set, the proper waveform is loaded from a table. If the note is not found, the appropriate file is opened and the first couple seconds are loaded into wave. That wave is stored in a map associated with that note. The Piano object controls the duration of the note. It uses the Piano Node class to generate while a note is still ongoing. 
      </p>

      <p>
      A Piano Node class is used to implement effects. A default attack and decay are set. If the pedal is down, the decay is reversed and a new decay is implemented. The pedal object is set in the Piano Factory whenever a Pedal note is played, indicating that the pedal has been pressed or released. Once the Piano classes generate a sound, it is added to the overall sound created by the synthesizer."
      </p>
      </br>
      <p>Well said, Sam.</p>
    </div>

    <a href="" class="js-vertical-tab-accordion-heading vertical-tab-accordion-heading" rel="tab2">Jacob Hersha</a>
    <div id="tab2" class="js-vertical-tab-content vertical-tab-content">
      <h3 class="bigquote">"I was able to create every affect for the Organ instrument. It's awesome."</h3> 

      </br>

      <p>"The hardest part was the Leslie speaker since it's a complicated instrument. 
      At first I tried to just create one class to implement all aspects of the organ.
      This was difficult and it was very hard to understand how I would change some Leslie effects.  
      Noting this, I followed the tutorial that came with the project.  Creating an envelope class
      like the OddSines class was very straightforward, as a lot of this was also
      done in Step 5.</p>  


      <p>After following the tutorial and creating an instrument, instrument factory,
      and wave class all that was left to do was figure out equations and
      algorithms for my instrument.  The tutorial made changing attributes
      and passing sound very easy.  I would say the easiest aspect was the envelope
      generation and the drawbar attributes. The drawbar was simple math that was
      just created using the decibel equation. The amplitudes of the drawbars
      would then be applied to the harmonics for the note.</p> 

      <p>Much of the work was done in the wave class.  Vibrato was fairly straightforward.
      All I did was generate a sine wave that was made by the vibrato phase difference that
      was caused by the magntiude of the vibrato for a note.</p>

      <p>For the Leslie effets, quite a bit amount of thought had to be put in. I conquered
      creating these effects by simply making an attribute for every effect of the speaker.
      I had to make "if" statements that would affect the phase of the Leslie. These
      statements would be determined by using the time of the program and seeing
      where the attack or release points of the Leslie were.  The phase would
      then be put into a sample frame that would replace the original frames.  This sample
      frame will have the new amplitude from the drawbar with the new phase that has 
      the vibrato and Leslie effects included.</p>

      <p>In my envelope class, I just used "if" statements to calculate attack, release, and decay
      equations.  These equations just take into effect the entered attack, decay, or release
      numbers and adjust the gain then the frame is assigned that gain."</p>
      </br>
      </br>
      <p>Keep up the great work, Jacob. You da real MVP.</p>
    </div>

    <a href="" class="js-vertical-tab-accordion-heading vertical-tab-accordion-heading" rel="tab3">Joshua Folks</a>
    <div id="tab3" class="js-vertical-tab-content vertical-tab-content">
      <h3>"Josh spends most of his freetime doing freelance drum work."</h3>
      </br>
      </br>
      <p>Drum Synthesizer Component
      
      </br>
      Implemented by: Joshua Folks
      
      </br>
      Functions:
      
      </br>
      "The Drum Synthesizer is composed of many functions, when added together, create various sounds that are sampled from a real life drum. The synthesizer works by loading 20 different drum samples at the very beginning of the program. The tutorial that was given in class was very helpful to complete this component. The files are then saved in a wavetable and played from the wave player class. The waveÕs are then loaded back from the Drum Factory. When playing the samples of the drum, they are enveloped, from Drum Envelope, in order to avoid the pop/click at the end of each sample. For the pitch, I made the sample much faster based on the user input. 
      
      </br>
      The Drum Synthesizer is able to create its own synthetic drum sound that correlates to a specific drum sound. The pitch is set by the user and this initiates the synthetic sound. The synthetic drum sound is made by starting with a base sine wave as a note, adding random waves as "white noise" to this sine wave, creating a sweeping effect that increases the frequency of the sine wave at the beginning of the wave and decreases the frequency at end, and finally, putting this wave through an envelope that adds Attack and Release processing to the sine wave.
      
      </br>
      Supporting the waveform playback, envelope generation, polyphony, and 21 different drum sounds including the synthesized drum, the Drum Synthesizer Component is complete with every requirement implemented."
      
      </br>
      
      <h5>Drum Synthesizer Score Format:</h5>
      
      <p>
      < note measure="1" beat=Ò1.0Ó note=ÒC1Ó pitch =Ò2Ó />
      
      </br>
      This is the simple format that is used to write the score of the drum. The initial note will come after the instrument is declared as ÒDrumÓ. The measure, beat, and note are all very basic parameters for the score file. The pitch parameter is an optional value that you can set to vary the pitch of the particular sound. When the pitch is set on the score file the actual synthesized drum is built and played at the varied pitch that the user has chosen. The notes of the drum synthesizer are correlated with the actual sound of a drum that is being loaded in. 
      
      </br>
        Cymbal = C ex. C1 = cymbal1
      </br>
        Bass = B   ex. B1 = bass1
      </br>
        Tom1 = A   ex. A1 = tom11
      </br>
        Tom2 = D   ex. D1 = tom21
      </br>
        Snare = S  ex. S1 = snare1
      </br>
      
      All of the notes are in the solution folder and are saved as a .wav file.</p>
      </br>
      </br>
      </br>
      <p>Boom. Drop the mic.</p>
    </div>

    <a href="" class="js-vertical-tab-accordion-heading vertical-tab-accordion-heading" rel="tab4">Joshua Johnson</a>
    <div id="tab4" class="js-vertical-tab-content vertical-tab-content">
      <h3>"My effects really bring the whole project together."</h3>
      </br>
      </br>
      <p>The effects change the output from all of the instruments in the synthesizer.</p>
      
      <h5>
      Effects score options:
      </h5>
      <p>
      gateWet
      </br>
      gateDry
      </br>
      compressWet
      </br>
      compressDry
      </br>
      flangeWet
      </br>
      flangeDry
      </br>
      chorusWet
      </br>
      chorusDry
      </p>
      
      <p>
      "For a given note from another instrument given as follows:
      < note measure="1" beat="1" duration="1" note="B4" dynamic ="1.0"/>
      
      The flange effect would be implemented as follows:
      < note measure="1" beat="1" duration="1" note="B4" dynamic ="1.0" flangeWet="1.0" flangeDry="0.0"/>
      
      Each option is used with a decimal value typically ranging from 0.0 to 1.0. The value can exceed 1.0, which would result in a gain of greater than 1.
      
      If no specification is made for any effect, it is given the default value of xDry = 1, xWet = 0, which causes no effect to be applied.
      </br>
      Implementation details:
      I created a class for each effect (Gate, Compress, Flange, and Chorus). If more time was available, these would have been refactored and would include a base class for the Effects. Also, Flange and Chorus would have been made into a single class or at least have their own base class, since their implementation is nearly identical.
      
      The implementation for Chorus and Flange were discussed in preparation for the exam; these use a sine wave to vary the selection location of sounds recently generated.
      
      The Gate and Compress effects simply do calculations on the current value of the sound generated, whether limiting or increasing the sound, depending on the effect.
      
      For integrating the effects into the system, each instrument was allocated an instance of each effect. This was done so that effects could be individually applied to meet the requirement for Controllable effects. This allows for dynamic and fully selectable effects sends."</p>
      </br>
      </br>
      <p>Josh is a world renowned effects mixer and we were he could take a break from his worldwide trap music tour to help us with our synth.</p>
    </div>
  </div>
</div>

<br>
